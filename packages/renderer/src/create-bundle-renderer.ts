
import fs from 'fs'
import path from 'path'
import { createBundleRunner, files, entry } from './create-bundle-runner'
import { createSourceMapConsumers, rewriteErrorTrace, mapConsumers, rawMaps } from './source-map-support'

const INVALID_MSG =
  'Invalid server-rendering bundle format. Should be a string ' +
  'or a bundle Object of type:\n\n' +
  `{
  entry: string;
  files: { [filename: string]: string; };
  maps: { [filename: string]: string; };
}\n`

// The render bundle can either be a string (single bundled file)
// or a bundle manifest object generated by vue-ssr-webpack-plugin.
type RenderBundle = {
  basedir?: string;
  entry: entry;
  files: files;
  maps: rawMaps;
  modules?: { [filename: string]: string[] };
};
export type Renderer = {
  renderToString: (App: any, props: any) => Promise<string> | string;
};
export type RenderOptions = {
  modules?: { [filename: string]: string[] };
  template?: string | ((content: string, context: any) => string);
  inject?: boolean;
  basedir?: string;
  runInNewContext?: boolean | 'once';
};

export type context = object;
export function createBundleRendererCreator(
  createRenderer: (options?: RenderOptions) => Renderer,
) {
  return function createBundleRenderer(
    bundle: string | RenderBundle,
    rendererOptions: RenderOptions = {},
  ): Renderer {
    let entry: entry
    let files: files
    let maps: mapConsumers
    let basedir: string | void = rendererOptions.basedir

    // load bundle if given filepath
    if (
      typeof bundle === 'string' &&
      /\.js(on)?$/.test(bundle) &&
      path.isAbsolute(bundle)
    ) {
      if (fs.existsSync(bundle)) {
        const isJSON = /\.json$/.test(bundle)
        basedir = basedir || path.dirname(bundle)
        bundle = fs.readFileSync(bundle, 'utf-8')
        if (isJSON) {
          try {
            bundle = JSON.parse(bundle)
          } catch (e) {
            throw new Error(`Invalid JSON bundle file: ${bundle}`)
          }
        }
      } else {
        throw new Error(`Cannot locate bundle file: ${bundle}`)
      }
    }

    if (typeof bundle === 'object') {
      entry = bundle.entry
      files = bundle.files
      basedir = basedir || bundle.basedir
      maps = createSourceMapConsumers(bundle.maps)
      if (typeof entry !== 'string' || typeof files !== 'object') {
        throw new Error(INVALID_MSG)
      }
    } else if (typeof bundle === 'string') {
      entry = '__etsx_ssr_bundle__'
      files = { __etsx_ssr_bundle__: bundle }
      maps = {}
    } else {
      throw new Error(INVALID_MSG)
    }

    const renderer = createRenderer(rendererOptions)

    const run = createBundleRunner(
      entry,
      files,
      basedir || process.cwd(),
      rendererOptions.runInNewContext,
    )

    return {
      renderToString: (context?: context): Promise<string> => {
        context = context || {}
        return run(context)
          .then((App: any) => {
            if (App) {
              return renderer.renderToString(App, context)
            } else {
              return Promise.reject(new Error('not App'))
            }
          })
          .catch((err: Error) => {
            rewriteErrorTrace(err, maps)
            return Promise.reject(err)
          })
      },
    }
  }
}
